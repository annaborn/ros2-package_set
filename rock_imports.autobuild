def generate_package_xml(pkg, dependencyname)
    #puts "generate_package_xml" + pkg.srcdir + "/package.xml"
    if !File.exist?(pkg.srcdir + "/package.xml") then
        puts "  package.xml not present, generating for " + pkg.name
        content = \
        %{<?xml version="1.0"?>
<package format="2">
  <name>#{dependencyname}</name>
  <version>0.0.0</version>
  <description>auto generated file, see manifest.xml for information</description>
        }

        pkg.dependencies.each do |dep|
            content = content + "  <build_depend>#{dep.gsub("/","-")}</build_depend>\n"
        end

        content += %{
  <maintainer email="steffen.planthaber@dfki.de">Steffen Planthaber</maintainer>
  <license>Copyright DFKI</license>
  <export>
    <build_type>cmake</build_type>
  </export>
</package>
        }
        #puts content
        File.open(pkg.srcdir + "/package.xml", 'w') { |file| file.write(content) }
    end
end


def rock_import_package(name, libname: name, workspace: Autoproj.workspace)
    ros_packagename = libname.gsub("/","-")
    package_common(:import, name, workspace: workspace) do |pkg|
        pkg.post_import do 
            #if no package.xml exist, generate one including the dependencies
            generate_package_xml(pkg, ros_packagename)
        end
        yield(pkg) if block_given?
    end
    # add a metapackage to have both package definitions in autoproj:
    # with '/' and '-' (colcon cannot have / in package names), so aup
    # needs know the definition with '-' when calls from a plain ros2 package
    # with a manually written package.xml (use - version there to enable colcon to evaluate the dependency)
    metapackage ros_packagename, name
end

rock_import_package "base/cmake"
rock_import_package "base/logging"
rock_import_package "base/types"
rock_import_package "control/motor_controller"
